---
title: "Data Visualisation in R"
output: 
  learnr::tutorial:
    css: "css/style.css"
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
# Author: Russell McCreath
# Original Date: June 2021

library(learnr)
library(gradethis)
library(readr)
library(dplyr)
library(ggplot2)
library(datasauRus)
library(magrittr)
library(tidyr)
library(kableExtra)

knitr::opts_chunk$set(echo = FALSE)

tutorial_options(
  exercise.checker = gradethis::grade_learnr
)

borders_data <- read_csv("www/data/BORDERS (inc Age).csv")
sp_child_immunisations_data <- read_csv("www/data/scotpho_childhood_immunisations.csv")

```

```{r phs-logo, echo=FALSE, fig.align='right', out.width="40%"}
knitr::include_graphics("images/phs-logo.png")
```


## Introduction

Welcome to an Introduction to Data Visualisation in R. This course is designed as a self-led introduction for anyone in Public Health Scotland. Throughout this course there will be quizzes to test your knowledge and opportunities to modify and write R code (building your own visualisations). This course focusses on the use of the package `ggplot2` but will introduce some concepts from `plotly`.

<div class="info_box">
  <h4>Course Info</h4>
  <ul>
    <li>This course is built to flow through sections and build on previous knowledge. If you're comfortable with a particular section, you can skip it.</li>
    <li>Most sections have multiple parts to them. Navigate the course by using the buttons at the bottom of the screen to Continue or go to the Next Topic.</li>
    <li>The course will also show progress through sections, a green tick will appear on sections you've completed, and it will remember your place if you decide to close your browser and come back later.</li>
  </ul>
</div>
</br>

### What is Data Visualisation?

Data visualisation is an essential skill across the spectrum of data science. It is a form of graphical data analysis, which emphasises the accurate representation and interpretation of data. On the other hand, data viz also relies on good design choices, not only to make the outputs attractive but also aiding the understanding of the results. 

There are two main types of data viz:

* **Exploratory** - easily generated, data-heavy, intended for a small specialist audience. This use case here is for graphical data analysis.
* **Explanatory** - labour intensive, data specific, and intended for a broad audience. This use case could be in publications or presentations.

*Render 2 plots to visualise the difference?*

```{r intro-quiz}
quiz(
  question("Let's get started. Which of the following are exploratory plots typically NOT?",
    answer("Pretty", correct = TRUE),
    answer("Meant for a specialist audience"),
    answer("Data-heavy"),
    answer("Rough first drafts"),
    answer("Part of our data science toolkit as graphical data analysis"),
    incorrect = "Not quite, have another go!",
    allow_retry = TRUE,
    random_answer_order = TRUE
  )
)
```


### Ineffective Data Visualisation

Visualising data is an art as much as a science. There are a number of issues to be aware of, including presenting multi-dimensional data, human perception and accessibility, and just generally misleading presentations. 

Let's take these visualisations as an example, what do you think is common across all of them?

```{r datasauRus-plot, echo=FALSE}
ggplot(datasaurus_dozen, aes(x=x, y=y))+
    geom_point(colour = "#433683", alpha = 0.5) +
    theme_void() +
    theme(legend.position = "none", aspect.ratio = 1) +
    facet_wrap(~dataset, ncol=5)
```

```{r datasaurus-quiz}
quiz(
  question("What are the common features across these sets of data?",
    answer("Mean", correct = TRUE),
    answer("Standard Deviation", correct = TRUE),
    answer("Correlation", correct = TRUE),
    correct = "That's right, summary statistics for all the datasets are the same.",
    incorrect = "Is that all?",
    allow_retry = TRUE,
    random_answer_order = TRUE
  )
)
```


### Effective Data Visualisation

The previous visualisations are a *fun* variant on Anscombe's Quartet, called the [The Datasaurus Dozen](https://www.autodesk.com/research/publications/same-stats-different-graphs). The summary statistics are shown below:

```{r datasaurus-stats, echo=FALSE, rows.print=14}
datasaurus_dozen %>% 
    group_by(dataset) %>% 
    summarize(
      mean_x    = mean(x),
      mean_y    = mean(y),
      std_dev_x = sd(x),
      std_dev_y = sd(y),
      corr_x_y  = cor(x, y)
    ) %>%
  mutate(across(2:6, round, 3))
```

The key takeaway should be to model your data, visualise to understand your data attributes. However, there are also other considerations for how plot's should be:

* **Conceptually** correct - data is represented visually in a way that makes sense.
* **Technically** correct - details of the data representation are complete and accurate.
* **Aesthetically** correct - data is represented in a visually pleasing way.


## Foundations

We're going to use the package `ggplot2` for most of this course. So, let's start by building a plot to see what all of this is about. We can then take the code apart bit by bit to understand what's going on (and what's possible). Feel free to adjust the code and see how it affects the output.

```{r prepare-foundations-plot}
borders_data_plot <- borders_data %>%
  filter(Sex %in% c("Male", "Female"),
         ageonadmission >= 0) %>% 
  drop_na(Sex)
```

```{r foundations-plot, exercise=TRUE, exercise.setup='prepare-foundations-plot', warning=FALSE}
library(ggplot2)

borders_data_plot %>%
  ggplot(aes(x = ageonadmission, 
             y = LengthOfStay, 
             colour = Sex)) +
  geom_point(alpha = 0.5) +
  theme_minimal() +
  ylab("Length of Stay (days)") +
  xlab("Age on Admission (years)") +
  ggtitle("Length of Stay by Age on Admission")

```

</br>

There we have it, in just a few lines of code, we've created a plot. You may even have already worked out what some of the code does. We're now going to take a step back to understand how all of this comes together. 

It comes from an underlying grammar of graphics, a framework which follows a layered approach to describe and construct visualisations or graphics in a structured manner. There are 7 grammatical elements:

```{r, echo=FALSE}
graphics_grammar_table <- data.frame(
  "Element" = c("**Data**", 
                "**Aesthetics**", 
                "**Geometries**", 
                "**Themes**", 
                "**Statistics**", 
                "**Coordinates**",
                "**Facets**"),
  "Description" = c("The data-set being plotted.", 
                    "The scales/axes based on the data dimensions. Any form of encoding, including size, shape, color and so on which are useful for plotting multiple data dimensions.", 
                    "These are popularly known as ‘geoms’. This would cover the way we would depict the data points on the visualisation. Should it be points, bars, lines and so on.", 
                    "The additional, non-data, ink on our outputs. These add value and make things look pretty.", 
                    "Statistical measures in the visualisation like measures of central tendency, spread, confidence intervals.", 
                    "What kind of a coordinate system should the visualization be based on?", 
                    "Subplots based on specific data dimensions."),
  "Common Options" = c("", 
                       "`x-axis` `y-axis` `colour` `fill` `size` `labels` `alpha` `shape` `line-width` `line-type`",
                       "`point` `line` `histogram` `bar`", "", "`binning` `smoothing` `descriptive` `inferential`",
                       "`cartesian` `fixed` `polar` `limits`", 
                       "`columns` `rows`"),
  check.names = FALSE
)

kableExtra::kbl(graphics_grammar_table) %>%
  kable_paper(full_width = FALSE)

```

</br>

<div class="viz-layers">
```{r viz-layers, echo=FALSE, fig.align='center', out.width="90%"}
knitr::include_graphics("images/data-viz/layers.png")
```
</div>

This shows how the layers of the grammar of graphics build up. It's also important to know that while data is required, the layers above become more optional (not every plot needs additional statistical measures). The use of these layers will depend on the use of the visualisation, the audience, and even the medium it's being shared on (i.e., web, pdf, image). You may also see similar representations with slightly different names or ordering.

Using only the first 4 layers (data, aesthetics, geometries, and themes), we'll be able to create publication-quality plots. The final 3 layers will be explored at a higher level for those who are interested.

</br>


## Data

This is going to be a short section but important nonetheless. The basis for any visualisation is the data, however it's rarely useful to look at the numbers and characters that make up a dataset. Some visualisation is required to show relationships. 

As mentioned, we're going to mainly use the `ggplot2` package in this course. There are a few reasons for this but it breaks down to being able to create relatively complex and aesthetically pleasing plots using syntax that is intuitive and comparatively easy to remember. However, a requirement for using the package effectively is that the data must be [tidy data](https://vita.had.co.nz/papers/tidy-data.pdf). *This can be summarised as observations in rows and variables as columns*. Have a look at the [`tidyr`](https://tidyr.tidyverse.org/) package to explore how to make data tidy in the Tidyverse.

The dataset used in the last exercise is the borders training dataset and will continue popping up throughout this course. Have a look at its structure below using `glimpse()` (a tidy-output of `str()`).

```{r data-view, exercise=TRUE}
___(borders_data)

```

```{r data-view-hint-1}
glimpse(borders_data)

```

Let's build another plot too. Run the code below and feel free to play around with it. We'll learn how it all comes together in the next chapters. Just remember we're using that tidy data as our solid foundation which is piped in as the first argument to `ggplot()`:

```{r data-plot, exercise=TRUE, warning=FALSE}
borders_data %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission)) +
  geom_boxplot(outlier.colour = "magenta4") +
  xlab("Specialty Grouping") +
  ylab("Age on Admission (years)") +
  ggtitle("Boxplot of Patient Age on Admission by Specialty Grouping")
```


## Aesthetics

Aesthetic mappings describe how properties of the data connect with features of the graph, such as distance along an axis, size of points, or colour. Aesthetic mappings are how dimensions of the data are visualised, commonly through the `x` and `y` axes, more dimensions could be added by including colour, different types of line or shapes, etc. The `aes()` function connects data with what we see on the graph by defining aesthetic mappings and will be one of the most often used functions when you're creating data visualisations. 

The `aes()` function is passed after the data to the `ggplot()` function. However, it is often used as the first argument of the next layer, a geometry function, (e.g. `geom_line()`). When passed on the geometry layer, different mappings can be used across different geometries (overlaying a line on a bar chart for instance). We will keep `aes()` alongside our data inside the `ggplot()` function which means it'll be used as the default mapping for all layers of the output. 

Let's look at our first example:

1. Our data, `borders_data_plot` is piped into the `ggplot()` function. 
2. Aesthetic mappings are added to the `ggplot()` function, defining our `x` and `y` variable mappings. 
3. A 3rd dimension is visualised by mapping colour to another variable.
4. The geometry layer (a scatter plot here) is added on (using `+`) to create an output.

``` {r aesthetics-plot, exercise=TRUE, exercise.setup='prepare-foundations-plot', warning=FALSE}
borders_data_plot %>%
  ggplot(aes(x = ageonadmission, 
             y = LengthOfStay, 
             colour = Sex)) +
  geom_point()
```


### Mappings

In addition to the `x`, `y`, and colour aesthetics, there are a number of other options. These are dictated somewhat by the choice of geometry used but allow the visuals to be improved and further dimensions to be added to the plot. These are some typical visible aesthetics:

```{r, echo=FALSE}
aesthetic_map_table <- data.frame(
  "Aesthetic" = c("**`x`**", 
                  "**`y`**", 
                  "**`colour`**", 
                  "**`fill`**", 
                  "**`size`**", 
                  "**`alpha`**", 
                  "**`linetype`**", 
                  "**`shape`**", 
                  "**`labels`**"),
  "Description" = c("The `x` axis position", 
                    "The `y` axis position", 
                    "Colour of points, outlines of other geoms", 
                    "The colour of the fill", 
                    "Area or radius of points, thickness of lines", 
                    "The level of transparency (out of 1)", 
                    "The pattern used for drawing lines (solid, dashed, dotdash, etc.)", 
                    "The shape of points, some of which allow a `fill` to be specified", 
                    "Text on the plot or axes")
)

kableExtra::kbl(aesthetic_map_table) %>%
  kable_paper(full_width = FALSE)

```

We can use some of these aesthetic mappings to refer to continuous or categorical data. However, some are restricted to categorical. Can you tell which of these pairs would only suit categorical data?

```{r aesthetic-quiz}
quiz(
  question("Which aesthetics are only applicable to categorical data?",
    answer("`colour` and `fill`"),
    answer("`alpha` and `size`"),
    answer("`label` and `shape`", correct = TRUE),
    answer("`alpha` and `label`"),
    answer("`x` and `y`"),
    incorrect = "Categorical data has a finite set of options which can be divided into groups/labelled. Have another go!",
    correct = "Brilliant! Continuous data works on a scale and should be represented by a smooth spectrum. Categorical data, however, needs some defined, finite, property.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  )
)
```


#### Mappings vs. Attributes

Many of these aesthetics function as both aesthetic mappings but also attributes. This is something to watch out for as it's a common mistake. To declare an attribute, determining how something looks (e.g. changing the alpha of every point, not mapping to a variable) it should be defined as part of the geom and not in the `aes()` function.

Let's take an example. Using the same code as above, change the colour of points to be "dark green" for all points. Use the hint button if you need some guidance.

``` {r aesthetics1, exercise=TRUE, exercise.setup='prepare-foundations-plot', warning=FALSE}
borders_data_plot %>%
  ggplot(aes(x = ageonadmission, 
             y = LengthOfStay, 
             colour = Sex)) +
  geom_point()
```

``` {r aesthetics1-hint-1}
borders_data_plot %>%
  ggplot(aes(x = ageonadmission, 
             y = LengthOfStay)) +
  geom_point(colour = ___)
```

``` {r aesthetics1-solution}
borders_data_plot %>%
  ggplot(aes(x = ageonadmission, 
             y = LengthOfStay)) +
  geom_point(colour = "dark green")
```

``` {r aesthetics1-check}
grade_code()
```


### Modifying Aesthetics

While we now know how to map data to aesthetics, it may still be necessary to make further modifications. For instance, if there is a lot of overlapping data points, the chosen aesthetic may hide valuable insights. It's also important to remember that each of the aesthetics is a scale and may need to be fine tuned, like changing the limits of an axis to start at 0. As each of the modifications will impact a particular geometry layer, these modifications are called as part of that layer (i.e. `geom_<type>`) and not within the `aes()` function.


#### Positions

It's quite common to adjust position, this is how you can account for overlapping data. The default position is "identity" which means that it takes the value exactly as it is in the data to position within the plot. There are a number of other options available though:

```{r, echo=FALSE}
position_mods_table <- data.frame(
  "Function" = c("**`position_dodge()`** **`position_dodge2()`**", 
                 "**`position_identity()`**", 
                 "**`position_jitter()`**", 
                 "**`position_jitterdodge()`**", 
                 "**`position_nudge()`**", 
                 "**`position_stack()`**", 
                 "**`position_fill()`**"),
  "Description" = c("Dodge overlapping objects side-to-side, preserving the vertical position. The `position_dodge()` version requires a grouping in the data, `position_dodge2()` doesn't", 
                    "No adjustment to position *(default)*", 
                    "A pseudo-randomisation of points to seperate them", 
                    "Simultaneously dodge and jitter", 
                    "Nudge points a fixed distance", 
                    "Stacks bars on top of each other", 
                    "Stacks bars and standardises each stack to have constant height")
)

kableExtra::kbl(position_mods_table) %>%
  kable_paper(full_width = FALSE)

```

These functions are passed to the `position` argument within a geometry layer function. If we take the first example and add a jitter to the points, it would look like this:

``` {r, eval=FALSE, echo=TRUE}
borders_data_plot %>%
  ggplot(aes(x = ageonadmission, 
             y = LengthOfStay, 
             colour = Sex)) +
  geom_point(position = position_jitter())
```

Let's look at our data set from the first example and compare specialty grouping (`spec_1`) against `LengthOfStay` (run the code chunk below to see the plot). We can see that we have a lot of overlapping data points so it's difficult to really gather any insights from this. Let's do a few things:

1. Add a new dimension to map `Sex` to colour.
2. Apply both jitter and dodge.
3. Add an alpha attribute and set the value to '0.5'.

``` {r aesthetics2, exercise=TRUE, exercise.setup='prepare-foundations-plot', warning=FALSE}
borders_data_plot %>%
  ggplot(aes(x = spec_1, 
             y = LengthOfStay)) +
  geom_point()
```

``` {r aesthetics2-hint-1}
borders_data_plot %>%
  ggplot(aes(x = spec_1, 
             y = LengthOfStay,
             ___ = ___)) +
  geom_point()
```

``` {r aesthetics2-hint-2}
borders_data_plot %>%
  ggplot(aes(x = spec_1, 
             y = LengthOfStay,
             colour = Sex)) +
  geom_point()
```

``` {r aesthetics2-hint-3}
borders_data_plot %>%
  ggplot(aes(x = spec_1, 
             y = LengthOfStay,
             colour = Sex)) +
  geom_point(___ = ___)
```

``` {r aesthetics2-hint-4}
borders_data_plot %>%
  ggplot(aes(x = spec_1, 
             y = LengthOfStay,
             colour = Sex)) +
  geom_point(position = position_jitterdodge())
```

``` {r aesthetics2-hint-5}
borders_data_plot %>%
  ggplot(aes(x = spec_1, 
             y = LengthOfStay,
             colour = Sex)) +
  geom_point(position = position_jitterdodge(),
             ___ = ___)
```

``` {r aesthetics2-solution}
borders_data_plot %>%
  ggplot(aes(x = spec_1, 
             y = LengthOfStay,
             colour = Sex)) +
  geom_point(position = position_jitterdodge(),
             alpha = 0.5)
```

``` {r aesthetics2-check}
grade_code()
```


#### Scale

Scales are how aesthetics are set up and control the visual properties of the data values. We can access all the scales with the `scale_<name>_<data_type>` functions, which is immediately followed by which scale we want to modify. The third part of the function name is to match the type of data (e.g. discrete or continuous). Each of these functions will then have further arguments to alter the appearance of the output. There are also 'helper' type functions for common adjustments to labels and limits. The commonly used options are shown below:

```{r, echo=FALSE}
scale_mods_table <- data.frame(
  "Type" = c("Helper",
             "Helper",
             "Helper",
             "Helper",
             "Helper",
             "Axes",
             "Axes",
             "Colour & Fill",
             "Colour & Fill",
             "Shape",
             "Shape",
             "Line",
             "Line",
             "Size",
             "Size"),
  "Function" = c("**`labs()`**",
                 "**`xlab()`** **`ylab()`**",
                 "**`ggtitle()`**",
                 "**`lims()`**",
                 "**`xlim()`** **`ylim()`**",
                 "**`scale_x_continuous()`** **`scale_y_continuous()`**",
                 "**`scale_x_discrete()`** **`scale_y_discrete()`**",
                 "**`scale_colour_continuous()`** **`scale_fill_continuous()`**",
                 "**`scale_colour_discrete()`** **`scale_fill_discrete()`**",
                 "**`scale_shape()`**",
                 "**`scale_shape_manual()`**",
                 "**`scale_linetype_binned()`**",
                 "**`scale_linetype_discrete()`**",
                 "**`scale_size()`**",
                 "**`scale_radius()`**"),
  "Description" = c("Modify any label on the plot",
                    "Modify the label for the x or y axis",
                    "Modify the title and subtitle for the plot",
                    "Set scale limits",
                    "Set scale limits for the x or y axis",
                    "Position of scales for continuous data",
                    "Position of scales for discrete data",
                    "Colour and fill scales for continous data",
                    "Colour and fill scales for discrete data",
                    "Mapping no more than 6 discrete variables to shapes",
                    "Manually setting the shape mappings from levels in the data to aesthetic values",
                    "Scale for line patterns/types. Continuous values cannot be mapped to line types unless `scale_linetype_binned()` is used. *As linetypes have no inherent order, this is not advised.*",
                    "Scale for line patterns/types",
                    "Scales for area (commonly used for points and text)",
                    "Scales for radius"),
  "Arguments" = c("`...` (for any aesthetic-value pair), `title`, `subtitle`, `caption`, `alt`",
                  "`label`",
                  "`title` `subtitle`",
                  "`...` (for an aesthetic-value pair)",
                  "`...` (2 numeric values specifying the left/lower and right/upper limits, one value can be left as `NA`)",
                  "`name` `breaks` `minor_breaks` `n.breaks` `labels` `limits` `expand` `trans` `position`",
                  "`...` `palette` `breaks` `limit` `drop` `name` `labels` `expand` `position`",
                  "`...` `type` (one of 'gradient', 'viridis', or a function that returns a continous colour scale)",
                  "`...` `type` (one of a character vector or list of colour codes, or a function that returns a discrete colour/fill scale)",
                  "`...` `palette` `breaks` `limits` `drop` `na.translate` `name` `labels`",
                  "`...` `palette` `limits` `drop` `na.translate` `name` `labels`",
                  "`...` `palette` `breaks` `limits` `drop` `na.translate` `name` `labels`",
                  "`...` `palette` `breaks` `limits` `drop` `na.translate` `name` `labels`",
                  "`name` `breaks` `labels` `limits` `range` `trans` `guide`",
                  "`name` `breaks` `labels` `limits` `range` `trans` `guide`")
  
)

kableExtra::kbl(scale_mods_table) %>%
  kable_paper(full_width = FALSE) %>%
  collapse_rows(columns = 1)
```

To apply these functions, they are added on to the rest of the code with `+`. So, taking the previous example, we can add an axis name like so:

```{r, eval=FALSE, echo=TRUE}
borders_data_plot %>%
  ggplot(aes(x = ageonadmission, 
             y = LengthOfStay, 
             colour = Sex)) +
  geom_point(position = position_jitter()) +
  scale_x_continuous(name = "Age on Admission (Years)")
```

There is so much in that table (and that's not everything, even the possible arguments has been trimmed down for this) but remember it's not about remembering how to do everything, it's just knowing the possibilities. Remember, references are available and you can always use `?<function>` in the R console to get the help pages up.

So, let's put some of this into practice. Here, the data has been filtered to only include data relating to specialty group "H" or "J" and at Hospital Code "B120H". Let's tidy up the plot using the scale functions (not the helper functions) we now know about:

1. The variable names aren't easy to read and should be updated. Let's make the x-axis "Specialty Grouping" and the y-axis "Age on Admission (Years)".
2. It could be said that the visualisation is misleading due to the y-axis limits. Fix this by specifying the lower limit to be 0. This needs a length-2 vector (i.e. `c(x, y)`), remember the upper limit.
3. Let's also use some PHS colours rather than the defaults. Set "Female" (the first value) to be "#76B843" and "Male" (the second value) to be "#3A3776".
4. Finally, give the plot a title using `ggtitle()`. Let's call it "Boxplot of Age on Admission for Specialty Grouping H & J \\n in Borders General Hospital". (*The "\\n" is a special character that forces a new line, something that may be necessary in longer titles as ggplot doesn't automatically wrap the text*).


``` {r aesthetics3, exercise=TRUE, exercise.setup='prepare-foundations-plot', warning=FALSE}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot()
```

```{r aesthetics3-hint-1}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  ___(___ = ___) +
  ___(___ = ___)
```

```{r aesthetics3-hint-2}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)")
```

```{r aesthetics3-hint-3}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)", ___ = c(___, ___))
```

```{r aesthetics3-hint-4}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)", limits = c(0, NA))
```

```{r aesthetics3-hint-5}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)", limits = c(0, NA)) + 
  ___(___ = c(___, ___))
```

```{r aesthetics3-hint-6}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)", limits = c(0, NA)) + 
  scale_colour_discrete(___ = c(___, ___))
```

```{r aesthetics3-hint-7}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)", limits = c(0, NA)) + 
  scale_colour_discrete(type = c("#76B843", "#3A3776"))
```

```{r aesthetics3-hint-8}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() + 
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)", limits = c(0, NA)) + 
  scale_colour_discrete(type = c("#76B843", "#3A3776")) + 
  ___(___)
```

``` {r aesthetics3-solution}
borders_data_plot %>%
  filter(HospitalCode == "B120H",
         spec_1 %in% c("H", "J")) %>%
  ggplot(aes(x = spec_1, 
             y = ageonadmission,
             colour = Sex)) +
  geom_boxplot() +
  scale_x_discrete(name = "Specialty Grouping") +
  scale_y_continuous(name = "Age on Admission (Years)", limits = c(0, NA)) +
  scale_colour_discrete(type = c("#76B843", "#3A3776")) + 
  ggtitle("Boxplot of Age on Admission for Specialty Grouping H & J \n in Borders General Hospital")
```

``` {r aesthetics3-check}
grade_code()
```


### Final Thoughts & Best Practice

While there is a certain amount of creative know-how, it's also important to follow guidance that has been created. This will help form the most suitable presentation of data that is accessible, aligns with outputs produced across the organisation, and meets the needs and expectations of your audience.

Forms follows function - the best visualisations serve a purpose. This depends on your audience; you may be confirming your own suspicions, starting to analyse the data you have, or you may be trying to inform a lay reader of specific results. The priority is to always generate accurate and efficient representations of the data, otherwise it's rubbish. After that, we can be concerned about creating something that is visually interesting and appealing.

**Guiding Principles**

* **Always** consider the audience and purpose of every visualisation
* **Always** be accurate and efficient
* **Never** misrepresent or obscure data
* **Never** confuse viewers with complexity


#### Knowledge Check

```{r aesthetics-quiz}
quiz(
  question("What is the command that controls the opacity of geoms?",
    answer("Alpha", correct = TRUE),
    answer("Beta"),
    answer("Delta"),
    answer("Gamma"),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("What of these options can be used to account for overlapping data points (select 2)?",
    answer("`position_dodge()`", correct = TRUE),
    answer("`position_jitter()`", correct = TRUE),
    answer("`position_move()`"),
    answer("`position_dance()`"),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("What could we use to add another dimension to our visualisation if the data item is continuous?",
    answer("Fill", correct = TRUE),
    answer("Shape"),
    answer("Line Type"),
    answer("Texture"),
    allow_retry = TRUE,
    random_answer_order = TRUE
    )
)
```


## Geometry

The 3rd (essential) layer is the geometry (`geom`) layer. We've already seen this in action throughout our previous examples so you may have worked out what it does and how to use it. However, this is where we determine what type of plot it's going to be. There are about 50 options to chose from, but as you can probably imagine, you're much more likely to use a select few:

```{r, echo=FALSE}
geometries_table <- data.frame(
  "Group" = c("Scatter",
              "Scatter",
              "Scatter",
              "Bar",
              "Bar",
              "Bar",
              "Line",
              "Line",
              "Other"
             ),
  "Function" = c("**`geom_point()`**",
                 "**`geom_jitter()`**",
                 "**`geom_count()`**",
                 "**`geom_histogram()`**",
                 "**`geom_bar()`**",
                 "**`geom_col()`**",
                 "**`geom_line()`**",
                 "**`geom_path()`**",
                 "**`geom_smooth()`**"
                 ),
  "Description" = c("This is the foundation for the next 2 variations. Scatterplots are the most useful for displaying the relationship between 2 continuous variables. You can map another variable to `size` which will create a bubble chart from this.",
                    "A convenient shortcut for specifying jitter as the position. Adding a small amount of random variation to the location of points, useful for handling overplotting.",
                    "Counting the number of observations at each location.",
                    "A specialised version of bar plots. Showing the binned distribution of a continuous variable.",
                    "A bar with the height proportional to the number of cases in each group.",
                    "A bar with the height representing values in the data.",
                    "Connect observations based on the order on the x-axis.",
                    "Connect observations based on the order which they appear in the data.",
                    "Aiding in the visualisation of patterns where overplotting is an issue."
                    )
  
)

kableExtra::kbl(geometries_table) %>%
  kable_paper(full_width = FALSE) %>%
  collapse_rows(columns = 1)
```

With the layered approach, we can add multiple geoms to the same plot, just like another layer. If we remember back to the section on aesthetics, we can define the mappings within the geom layer which will allow us to use
different data mappings for each geom. We'll continue with defining `aes()` as part of the `ggplot()` call though. Let's see what 2 geoms will allow us to do:

``` {r, echo=TRUE, message=FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```


### Scatter Plots

Scatter plots have been quite common throughout this course so far. That's because they're generally useful, particularly in the exploratory side of data visualisation. 

Let's have a look at another scatter plot. This time there will be an obvious (albeit predictable) split in the data. Let's pull knowledge from the previous sections and create the full block of code. Don't worry, you'll still have guided steps and hints to help.

The data we're looking at has been filtered for you. We're looking at Specialties "AM" (Palliative Medicine) and "AF" (Paediatrics). We're going to create a scatter plot to see how age (on admission) impacts length of stay. Have a think about how you would expect this plot to look and then follow the steps below to see if you were right:

1. Set up the `ggplot()` function and add the aesthetic mappings ("ageonadmission" and "LengthOfStay").
2. Add a 3rd dimension to visualise "Specialty" with colour.
3. Make it a scatter plot with a jitter modification using the `position` argument.
4. Rename the legend labels to "Palliative" and "Paediatrics". (*Hint: they're discrete and mapped to colour, think about the order you write them too.*)
5. Change the axis labels to "Age" and "Length of Stay", you can use the helper functions for this.

``` {r geom1, exercise=TRUE, exercise.setup='prepare-foundations-plot'}
borders_data_plot %>%
  filter(Specialty %in% c("AM", "AF"))
```

``` {r geom1-solution}
borders_data_plot %>%
  filter(Specialty %in% c("AM", "AF")) %>%
  ggplot(aes(x = ageonadmission, y = LengthOfStay, colour = Specialty)) +
  geom_point(position = position_jitter()) + 
  scale_colour_discrete(labels = c("Paediatrics", "Palliative")) + 
  xlab("Age") +
  ylab("Length of Stay")
```

``` {r geom1-check}
grade_code()
```


### Histograms

Visualising the distribution of a single continuous variable by dividing the axis into bins and counting the number of observations in each bin. Let's create a histogram now:

1. Set up the `ggplot()` function and add the aesthetic mappings ("ageonadmission").
2. Add a 3rd dimension to visualise "Sex" with fill (colour would be an outline rather than *fill* the space).
3. Make it a histogram plot. If we look at this, we should note that bars are automatically stacked but this isn't obvious. Change the position to *dodge*.
4. We'll also see the automatic message about bin width. We could probably make this clearer by setting bin width to 10.
5. Change the axis labels to "Age" and "Count", you can use the helper functions for this.

``` {r geom2, exercise=TRUE, exercise.setup='prepare-foundations-plot'}
borders_data_plot %>%
  filter(Specialty %in% c("AM", "AF"))
```

``` {r geom2-solution}
borders_data_plot %>%
  ggplot(aes(x = ageonadmission, fill = Sex)) +
  geom_histogram(binwidth = 10, 
                 position = position_dodge()) +
  xlab("Age") +
  ylab("Count")
```

``` {r geom2-check}
grade_code()
```


### Line Graph

Connecting observations in order of the variable on the x-axis, line graphs are used particularly in time trends. So let's mix it up by using a new data set for this section and see how childhood immunisation uptake has varied over a number of years.

1. Set up the `ggplot()` function and add the aesthetic mappings ("year" and "measure").
2. Add a 3rd dimension to visualise the immunisation with colour.
3. Make it a line graph.
4. Immediately, we can notice what looks to a big difference in uptake between the immunisations. However, if we look at the limits on the y-axis, this could mislead us. So, let's change the limits. We want it to start at 0 but what would the upper limit be? While we're at it, let's change the name so it shows "Uptake (%)".
5. The x-axis only has tick labels for a few years but we have 14 in our data. The function has tried to minimise clutter but let's show 7 breaks which will be easier for to read. We can also update the name at the same time, call the x-axis "Year".
6. Finally, the legend's title is lower case and doesn't look very presentable. Let's make it proper case (*hint: the lenend is describing a discrete colour object*).

``` {r geom3, exercise=TRUE}
sp_child_immunisations_data
```

``` {r geom3-solution}
sp_child_immunisations_data %>%
  ggplot(aes(x = year, y = measure, colour = immunisation)) +
  geom_line() +
  scale_y_continuous(name = "Uptake (%)", limits = c(0, 100)) +
  scale_x_continuous(name = "Year", n.breaks = 7) + 
  scale_colour_discrete(name = "Immunisation")
```
